<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Skipper</title>

  <base href="/" />

  <!-- This meta viewport ensures the webpage's dimensions change according to the device it's on. This is called Responsive Web Design.-->
  <meta name="viewport"
    content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0" />
  <meta name="description" content="Skipper is a multi-modal, multi-model AI assistant. Skipper can work with you how you want. Want to interact with your voice? You can. Need Skipper to see something? Give it an image! Simply want text chat? That works too. Want to chat with OpenAI's GPT-4? Or Google's Gemini Pro? Or, want to chat with a model that runs locally on your device? You can do that too. Skipper is designed to be flexible and work with you." />

  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#202020" />
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="white" />

  <!-- These meta tags are Apple-specific, and set the web application to run in full-screen mode with a black status bar. Learn more at https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/MetaTags.html-->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-title" content="Skipper" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />

  <!-- This tag is used by the gpt-client CLI to identify template projects. Don't remove if you are using the CLI. -->
  <meta name="pwa-starter-template-identity" content="pwa-starter" />

  <!-- Imports an icon to represent the document. -->
  <link rel="icon" href="/assets/icons/maskable_icon_x48.png" type="image/x-icon" />

  <!-- Imports the manifest to represent the web application. A web app must have a manifest to be a PWA. -->
  <link rel="manifest" href="/manifest.json" />

  <!-- light mode and dark mode CSS -->
  <link rel="stylesheet" media="(prefers-color-scheme:light)"
    href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.0.0-beta.73/dist/themes/light.css">
  <link rel="stylesheet" media="(prefers-color-scheme:dark)"
    href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.0.0-beta.73/dist/themes/dark.css"
    onload="document.documentElement.classList.add('sl-theme-dark');">


  <script>
    // requestIdleCallback polyfill
    if (!window.requestIdleCallback) {
      window.requestIdleCallback = function (cb) {
        var start = Date.now();
        return setTimeout(function () {
          cb({
            didTimeout: false,
            timeRemaining: function () {
              return Math.max(0, 50 - (Date.now() - start));
            }
          });
        }, 1);
      }
    }
  </script>

  <script type="module" src="/src/app-index.ts"></script>
</head>

<body>
  <!-- Our app-index web component. This component is defined in src/pages/app-index.ts-->
  <app-index></app-index>

  <script type="module">
    import { Workbox } from 'workbox-window';

    window.onload = async () => {

      if (location.search.includes('share-target')) {
        const keys = await caches.keys();
        const mediaCache = await caches.open(
          keys.filter((key) => key.startsWith('media'))[0],
        );
        const image = await mediaCache.match('shared-image');
        if (image) {
          const blob = await image.blob();
          await mediaCache.delete('shared-image');
          // Handle the shared file somehow.

          console.log("shareTargetFile blob image", blob, image);

          if (!blob.name) {
            blob.name = "dropped file";
          }

          window.shareTargetFile = blob;
        }
      }

      if ('serviceWorker' in navigator) {
        const wb = new Workbox('/sw.js');
        let registration;

        const showSkipWaitingPrompt = async (event) => {
          // Assuming the user accepted the update, set up a listener
          // that will reload the page as soon as the previously waiting
          // service worker has taken control.
          wb.addEventListener('controlling', () => {
            // At this point, reloading will ensure that the current
            // tab is loaded under the control of the new service worker.
            // Depending on your web app, you may want to auto-save or
            // persist transient state before triggering the reload.
            window.location.reload();
          });

          wb.messageSkipWaiting();
        };

        // Add an event listener to detect when the registered
        // service worker has installed but is waiting to activate.
        wb.addEventListener('waiting', (event) => {
          showSkipWaitingPrompt(event);
        });

        wb.addEventListener('installed', event => {
          if (event.isUpdate) {
            if (confirm(`New content is available!. Click OK to refresh`)) {
              window.location.reload();
            }
          }
        });

        wb.register();
      }
    }
  </script>
</body>

</html>